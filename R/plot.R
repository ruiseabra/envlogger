#' Plot data from one EnvLogger
#'
#' @inheritParams cctbon_summarise
#' @param cctbon_data a tibble generated by `READ_ENV(..., just_rep = TRUE)`, with logger names structured according to the CCTBON scheme, or a character vector of paths to files that can be read by [READ_ENV()] (or folders containing such files).
#' @param discard_mic string vector, defaults to `NULL`; use to discard specific microhabitats from the plot.
#' @param dy logical, defaults to `FALSE`; whether to print an interactive dygraph instead (some of the other parameters become irrelevant)
#' @param smooth logical, defaults to `FALSE`; whether to plot a loess smoothed curve instead.
#' @param stat character string, defaults to `avg`; the stat to be plotted if any of `by_micro`, `by_shore` or `by_day` is set to `TRUE`; one of `min`, `q10`, `q25`, `avg`, `q50`, `q75`, `q90`, `max`, or `sd`.
#' @param col_by character string, defaults to `id`; the color scale to be used; one of `id`, `sh`, `exp`, `lvl` or `mic` for each logger, exposure to solar radiation, height level in the shore and microhabitat, respectively.
#' @param ribbon logical, defaults to `FALSE`; whether to add a min-max ribbon.
#' @param ribbon_alpha numeric, defaults to `0.3`; a value from 0 to 1 indicating the transparency level of the ribbon (0 is fully transparent, 1 is fully solid).
#' @param facet_row character string, defaults to `NULL`; if set, the chosen variable is used to establish facetting rows; values allowed are `sh`, `exp`, `lvl` or `mic` (same meaning as in `col_by`).
#' @param facet_col same as `facet_row`, but to set facetting columns.
#' @param xlim_common logical, defaults to `FALSE`; whether to trim edges to only include data during common time ranges across all shores.
#' @param meters_corr numeric, defaults to `0`; a correction to be applied to the pressure data (if present in the dataset), in meters.
#'
#' @return
#' A ggplot
#'
#' @seealso [READ_ENV()]
#'
#' @export
#'
#' @examples
#' # a single EnvLogger file
#' paths1 <- env_example("ptzzwmh", no_logs = TRUE)[1]
#' plot_env(paths1) # by default, data is aggregated at least by day
#' plot_env(paths1, by_day = FALSE) # raw data
#'
#' # when "dy = FALSE", normal ggplot2 syntax can be used
#' plot_env(paths1, by_day = FALSE) +
#'   ggplot2::ggtitle("ggplot2 syntax example") +
#'   ggplot2::theme_classic() +
#'   ggplot2::scale_color_manual(guide = "none", values = "red")
#'
#' # same plot, but using the interactive dygraphs package
#' plot_env(paths1, dy = TRUE)
#' plot_env(paths1, dy = TRUE, by_day = FALSE) # raw data
#'
#' # similarly to ggplot2, dygraphs plots can also be customized
#' dygraphs::dyLegend(plot_env(paths1, dy = TRUE, by_day = FALSE), show = "follow")
#'
#' # if any path points to a file with pressure data,
#' # only entries with pressure data are plotted
#' paths2 <- env_example("ptzzx", no_logs = TRUE)
#' basename(paths2) # only "ptzzxmc01b" will be plotted
#' plot_env(paths2)
#' plot_env(paths2, dy = TRUE)
#' plot_env(paths2, dy = TRUE, meters_corr = 4)
#'
#' # plot data from multiple sites, microhabitats, etc
#' paths3 <- env_example(c("ptzzw", "nozzz"), dir = TRUE)
#' plot_env(paths3)
#'
#' # data series can be colored by shore, microhabitat,
#' # exposure to solar radiation and shore height level
#' plot_env(paths3, col_by = "sh")
#'
#' # facets can help differentiate groups of data series
#' plot_env(paths3, facet_row = "exp")
#'
#' # data from loggers sharing certain microhabitat
#' # types can be aggregated
#' plot_env(paths3,
#'          by_micro = TRUE,
#'          col_by = "mic")
#'
#' # facets and colors can be combined to further
#' # differentiate data series
#' plot_env(paths3,
#'          by_micro = TRUE,
#'          col_by = "sh",
#'          facet_row = "mic")
#'
#' # add ribbons to see the range of the data that has been aggregated
#' plot_env(paths3,
#'          by_micro = TRUE,
#'          col_by = "sh",
#'          facet_row = "mic",
#'          ribbon = TRUE)
#'
#' # by default, once aggregated, the solid line shows average
#' # temperature, but other metrics can also be quickly visualized
#' plot_env(paths3,
#'          by_micro = TRUE,
#'          col_by = "sh",
#'          facet_row = "mic",
#'          ribbon = TRUE,
#'          stat = "q90")
#'
#' # apply a rolling mean
#' plot_env(paths3,
#'          by_micro = TRUE,
#'          col_by = "sh",
#'          facet_row = "mic",
#'          ribbon = TRUE,
#'          stat = "q90",
#'          roll = 7)
#'
#' # plot a smoothed curve instead
#' plot_env(paths3,
#'          by_micro = TRUE,
#'          col_by = "sh",
#'          facet_row = "mic",
#'          ribbon = TRUE,
#'          stat = "q90",
#'          roll = 7,
#'          smooth = TRUE)
#'
#' # trim to a timespan when data was available for all data series
#' plot_env(paths3,
#'          by_micro = TRUE,
#'          col_by = "sh",
#'          facet_row = "mic",
#'          ribbon = TRUE,
#'          stat = "q90",
#'          roll = 7,
#'          xlim_common = TRUE)
#'
#' # use different colors
#' plot_env(paths3,
#'          by_micro = TRUE,
#'          col_by = "sh",
#'          facet_row = "mic",
#'          ribbon = TRUE,
#'          stat = "q90",
#'          roll = 7,
#'          xlim_common = TRUE) +
#'          ggplot2::scale_color_manual(values = c("black", "green")) +
#'          ggplot2::scale_fill_manual(values = c("black", "green"))
plot_env <- function(
    cctbon_data,
    discard_mic = NULL,
    dy       = FALSE,
    by_micro = FALSE,
    by_shore = FALSE,
    by_day   = TRUE,
    smooth   = FALSE,
    stat     = "avg",
    col_by   = "id",
    ribbon   = FALSE,
    ribbon_alpha = 0.3,
    facet_row    = NULL,
    facet_col    = NULL,
    roll_days    = 0,
    xlim_common  = FALSE,
    meters_corr  = 0
) {
  # check if 'stat' matches the available stats columns
  stats <- c("min", "q10", "q25", "avg", "q50", "q75", "q90", "max", "sd")
  if (!is.null(stat)) {
    stat <- stat[1]
    if (!(stat %in% stats)) cli::cli_warn(c("'stat' must either be 'NULL' or one of:", paste0(">> ", paste(stats, collapse = ", "), " <<"), "-> showing 'avg' instead"))
  } else {
    stat <- "avg"
  }

  if (any(class(cctbon_data) == class("char"))) {
    cctbon_data <- stringr::str_subset(cctbon_data, "/log_", negate = TRUE)
    cctbon_data <- READ_ENV(cctbon_data)
    cctbon_data <- cctbon_id(cctbon_data)
  }

  if (!is.null(discard_mic)) {
    cctbon_data <- dplyr::filter(cctbon_data, !mic %in% discard_mic)
  }

  col_press <- c("temp" = "#F5191C", "press" = "#3B99B1")
  col_hum   <- c("temp" = "#F5191C", "hum" = "#3B99B1")

  if (any(cctbon_data$pressure)) {
    # if there's any pressure/humidity available, only those data are plotted
    # pressure is preferential

    # PRESSURE
    x <- cctbon_data %>%
      dplyr::filter(pressure) %>%
      tidyr::unnest(cols = "data")
    if (meters_corr != 0) x$press <- x$press + meters_corr # attempt at accounting for atmospheric pressure

    if (dy) {
      # press dy ----

      # make xts
      x_xts <- x %>%
        dplyr::select(t, id, temp, press) %>%
        tidyr::pivot_wider(names_from = id, values_from = c(temp, press), names_sep = ".")
      options(xts_check_TZ = FALSE)
      x_xts <- xts::xts(dplyr::select(x_xts, -t), x_xts$t, tzone = "UTC")

      # find the right colors for each column
      cols <- x_xts %>%
        zoo::coredata() %>%
        colnames() %>%
        stringr::str_split("\\.") %>%
        purrr::map_chr(1)
      cols <- col_press[cols] %>% unname()

      # plot
      dygraphs::dygraph(x_xts) %>%
        dygraphs::dyRangeSelector() %>%
        dygraphs::dyOptions(
          colors = cols,
          connectSeparatedPoints = TRUE,
          stepPlot = FALSE
        ) %>%
        dygraphs::dyHighlight(highlightCircleSize = 5,
                              highlightSeriesBackgroundAlpha = 0.75,
                              hideOnMouseOut = FALSE) %>%
        dygraphs::dyLegend(
          show = "always",
          width = 200,
          labelsSeparateLines = TRUE,
          hideOnMouseOut = FALSE)
    } else {
      # press gg ----
      x <- x %>%
        tidyr::pivot_longer(
          cols = c(temp, press),
          names_to = "type",
          values_to = "val"
        )

      p <- ggplot2::ggplot(x, ggplot2::aes(t, val, group = id, col = type)) +
        ggplot2::xlab("") +
        ggplot2::ylab("") +
        ggplot2::geom_line() +
        ggplot2::scale_color_manual(values = col_press, guide = "none") +
        ggplot2::facet_grid(cols = ggplot2::vars(id), rows = ggplot2::vars(type), scale = "free_y")

      p + ggplot2::theme_bw()
    }
    # } else if(any(cctbon_data$humidity)) {
    } else if(FALSE) {
    # HUMIDITY
    x <- cctbon_data %>%
      dplyr::filter(humidity) %>%
      tidyr::unnest(cols = "data")

    if (dy) {
      # hum dy ----

      # make xts
      x_xts <- x %>%
        dplyr::select(t, id, temp, hum) %>%
        tidyr::pivot_wider(names_from = id, values_from = c(temp, hum), names_sep = ".")
      options(xts_check_TZ = FALSE)
      x_xts <- xts::xts(dplyr::select(x_xts, -t), x_xts$t, tzone = "UTC")

      # find the right colors for each column
      cols <- x_xts %>%
        zoo::coredata() %>%
        colnames() %>%
        stringr::str_split("\\.") %>%
        purrr::map_chr(1)
      cols <- col_press[cols] %>% unname()

      # plot
      dygraphs::dygraph(x_xts) %>%
        dygraphs::dyRangeSelector() %>%
        dygraphs::dyOptions(
          colors = cols,
          connectSeparatedPoints = TRUE,
          stepPlot = FALSE
        ) %>%
        dygraphs::dyHighlight(highlightCircleSize = 5,
                              highlightSeriesBackgroundAlpha = 0.75,
                              hideOnMouseOut = FALSE) %>%
        dygraphs::dyLegend(
          show = "always",
          width = 200,
          labelsSeparateLines = TRUE,
          hideOnMouseOut = FALSE)
    } else {
      # hum gg ----
      x <- x %>%
        tidyr::pivot_longer(
          cols = c(temp, hum),
          names_to = "type",
          values_to = "val"
        )

      p <- ggplot2::ggplot(x, ggplot2::aes(t, val, group = id, col = type)) +
        ggplot2::xlab("") +
        ggplot2::ylab("") +
        ggplot2::geom_line() +
        ggplot2::scale_color_manual(values = col_hum, guide = "none") +
        ggplot2::facet_grid(cols = ggplot2::vars(id), rows = ggplot2::vars(type), scale = "free_y")

      p + ggplot2::theme_bw()
    }
  } else {
    # no pressure or humidity data available means that the plot can be more complex
    # first, data can be summarised
    x <- cctbon_summarise(
      cctbon_data,
      by_micro  = ifelse(by_day, by_micro, FALSE),
      by_shore  = ifelse(by_day, by_shore, FALSE),
      by_day    = by_day,
      roll_days = roll_days
    ) %>%
      tidyr::drop_na()

    if (by_day) {
      x$temp <- dplyr::pull(x, stat)
    } else {
      x$avg <- x$temp
    }
    x$col  <- dplyr::pull(x, col_by)

    # ensure that colder shores get bluer colors when col_by = "sh"
    SH <- x %>%
      dplyr::group_by(sh) %>%
      dplyr::summarise(avg = mean(avg)) %>%
      dplyr::arrange(avg) %>%
      dplyr::pull(sh)
    x$sh <- factor(x$sh, levels = SH)

    # color scales
    N <- SH %>% length()
    col_sh <- if (N == 1) {
      "black"
    } else {
      grDevices::hcl.colors(n = N, palette = "Zissou 1")
    }
    names(col_sh) <- SH

    col_exp <- c(
      "c" = "#3B99B1",
      "h" = "#F5191C",
      "e" = "#E9B31F",
      "w" = "#7CBA96",
      "p" = "black"
    )

    col_lvl <- c(
      "l" = "#3B99B1",
      "m" = "#9FC095",
      "t" = "#E8A419",
      "s" = "#F5191C"
    )

    col_mic <- c(
      "lc" = "#99BFEF",
      "mc" = "#5295D4",
      "tc" = "#0066A5",
      "sc" = "#00366C",
      "lh" = "#F6B00B",
      "mh" = "#EF7000",
      "th" = "#CA2700",
      "sh" = "#7D0025",
      "lp" = "#259E98",
      "mp" = "#68C19D",
      "tp" = "#AFE2A3",
      "sp" = "#F9FFAF"
    )

    col_id <- grDevices::hcl.colors(n = x$id %>% unique() %>% length(), palette = "Zissou 1")
    names(col_id) <- x$id %>% unique()
    if (length(col_id) == 1) col_id <- "black"

    # if xlim_common = TRUE, trim edges to only include data during common time ranges
    if (xlim_common) {
      t0t1 <- x %>%
        dplyr::group_by(sh) %>%
        dplyr::summarise(t0 = min(t), t1 = max(t)) %>%
        dplyr::summarise(t0 = max(t0), t1 = min(t1))
      x <- dplyr::filter(x, dplyr::between(t, t0t1$t0, t0t1$t1))
    }

    if (dy) {
      # regular dy ----

      # colors
      x <- dplyr::mutate(x, id = paste(id, .data[[col_by]], sep = "."))
      col_dy <- get(paste0("col_", col_by))

      # make xts
      x_xts <- x %>%
        dplyr::select(t, id, temp) %>%
        tidyr::pivot_wider(names_from = id, values_from = temp)
      options(xts_check_TZ = FALSE)
      x_xts <- xts::xts(dplyr::select(x_xts, -t), x_xts$t, tzone = "UTC")

      # find the right colors for each column
      cols <- x_xts %>%
        zoo::coredata() %>%
        colnames() %>%
        stringr::str_split("\\.") %>%
        purrr::map_chr(2)
      cols <- col_dy[cols] %>% unname()
      if (length(cols) == 1) cols <- "black"

      # plot
      dygraphs::dygraph(x_xts) %>%
        dygraphs::dyRangeSelector() %>%
        dygraphs::dyOptions(
          colors = cols,
          connectSeparatedPoints = TRUE,
          stepPlot = FALSE
        ) %>%
        dygraphs::dyHighlight(highlightCircleSize = 5,
                              highlightSeriesBackgroundAlpha = 0.5,
                              hideOnMouseOut = FALSE) %>%
        dygraphs::dyLegend(
          show = "always",
          labelsSeparateLines = TRUE,
          hideOnMouseOut = FALSE)
    } else {
      # regular gg ----

      # facet_grid
      if (!is.null(facet_col)) x$facet_c <- dplyr::pull(x, facet_col)
      if (!is.null(facet_row)) x$facet_r <- dplyr::pull(x, facet_row)

      # initiate plot
      p <- ggplot2::ggplot(x, ggplot2::aes(t, temp, group = id, col = col)) +
        ggplot2::xlab("") +
        ggplot2::ylab("")

      # add ribbon
      if (ribbon) p <- p + ggplot2::geom_ribbon(ggplot2::aes(t, ymin = min, ymax = max, group = id, fill = col), col = NA, alpha = ribbon_alpha)

      if (smooth) {
        # add smooth line ...
        p <- p + ggplot2::geom_smooth(method = "loess", formula = y ~ x, linewidth = 0.5)
      } else {
        # ... or plot without smoothing
        p <- p + ggplot2::geom_line()
      }

      # apply facets
      if (!is.null(facet_col)) p <- p + ggplot2::facet_grid(cols = ggplot2::vars(facet_c))
      if (!is.null(facet_row)) p <- p + ggplot2::facet_grid(rows = ggplot2::vars(facet_r))
      if (!is.null(facet_col) & !is.null(facet_row)) p <- p + ggplot2::facet_grid(rows = ggplot2::vars(facet_r), cols = ggplot2::vars(facet_c))

      # apply scales and colors
      p <- p +
        ggplot2::guides(color = ggplot2::guide_legend(col_by), fill = "none") +
        ggplot2::scale_color_manual(values = get(paste0("col_", col_by))) +
        ggplot2::scale_fill_manual( values = get(paste0("col_", col_by)))

      p + ggplot2::theme_bw()
    }
  }
}
