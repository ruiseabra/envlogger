% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/summarise_env.R
\name{summarise_env}
\alias{summarise_env}
\title{Group EnvLogger data by id elements and summarise it}
\usage{
summarise_env(
  env,
  var = "temp",
  fun_list = NULL,
  by_day = TRUE,
  by_site = FALSE,
  by_group = FALSE,
  site = "site",
  group = c("lvl", "exp"),
  same_days = FALSE,
  roll_days = 0,
  by_day_lim = 50
)
}
\arguments{
\item{env}{The output of a call to \code{\link[=read_env]{read_env()}} (either directly, of the \verb{$report} element). Additionally, a call to \code{\link[=parse_id]{parse_id()}} or \code{\link[=add_info]{add_info()}} ensures more grouping options. In alternative, the output of a call to \code{summarise_env}.}

\item{var}{The name of a single column over which the function(s) in \code{fun_list} will be applied. Defaults to \code{temp}. Can also be set to \code{hum} or \code{press} if wanting to summarise using humidity or pressure data, respectively. Can also be any other name, as long as it exists as colnames and codes for a data type that will result in a single numeric value when processed by all functions provided in \code{fun_list}.}

\item{fun_list}{Named list with one or more functions to be applied to \code{var}. Each function must return a single numeric value. The names of the columns derived from applying the functions provided are taken from the names of \code{fun_list}. If \code{fun} has no names, generic names are generated. If not provided, the following stats are computed: min, q10 (10th quantile), q25, average, q50, q75, q90 and max.}

\item{by_day}{Whether to summarise values daily or at the native sampling interval.}

\item{by_site}{Whether to group by \code{site}.}

\item{by_group}{Whether to group by \code{group}.}

\item{site}{The name of the column that codes for site. If a vector with more than one element, elements are combined to form a new column by pasting values together. Only relevant if \code{by_site = TRUE}. Can be omitted if data follows the CCTBON naming scheme.}

\item{group}{One or more column names to combine as a grouping factor. If a vector with more than one element, elements are combined to form a new column by pasting values together. Only relevant if \code{by_group = TRUE}. Can be omitted if data follows the CCTBON naming scheme (in which case \code{lvl} and \code{exp} are used).}

\item{same_days}{Should the output only include data for days for which all distinct grouping ids (site + group) have data?}

\item{roll_days}{Compute a rolling mean over the x days before each data point. If \code{0} (default), no rolling mean is applied.}

\item{by_day_lim}{Maximum number (in thousands) of collective rows accepted when \code{by_day = FALSE}. If the aggregate number of rows exceeds this value, \code{by_day} will be automatically set to \code{TRUE}. This is to prevent an unintentional call requesting the computation of summary stats over datasets that are too large, a situation that may lead to R stalling.}
}
\value{
A tibble with unnested data containing all the combinations of \code{id} and \code{t} (time), as well as \code{site} and \code{group} if \code{by_site = TRUE} and \code{by_group} = TRUE, respectively, along with as many data summary columns as the number of functions provided using \code{fun_list}.
}
\description{
Takes an EnvLogger tibble resulting from a call to \code{\link[=read_env]{read_env()}}, groups data by grouping variables and summarises it. In the simplest case, grouping is only done along time (\code{by_day}). However, if logger ids have been broken into id elements with \code{\link[=parse_id]{parse_id()}} or \code{\link[=parse_id_cctbon]{parse_id_cctbon()}}, grouping can also be done across id elements. For example, if data follows the CCTBON naming scheme, data can be grouped by \code{site}, \code{lvl} (shore height level) or \code{exp} (exposure to solar radiation). This function exists mainly to condition data for \code{\link[=plot_env]{plot_env()}}, but can also be useful by itself.

Note that \code{summarise_env} can be called on the output of a previous call to \code{summarise_env}, allowing, for example, for first computing daily maximums, and then on a second call, to request an average of those daily maximums across all loggers sharing the same microhabitat.
}
\examples{
env <- read_env(
   env_example(c("ptzzy", "ptzzw")),
   new_interval = 60,
   show_progress = FALSE,
   show_warnings = FALSE)

env <- parse_id_cctbon(env)

# daily max for each logger
daily_max <- summarise_env(
   env,
   var = "temp",
   fun_list = list(max = max),
   by_day = TRUE
   )
daily_max

# daily minimum, average and maximum daily_max for each site
summarise_env(
   daily_max,
   var = "max",
   fun_list = list(
       dmax_min = min,
       dmax_avg = mean,
       dmax_max = max,
       sd = sd
       ),
   by_day = TRUE,
   by_site = TRUE,
   same_days = TRUE
   )
}
\seealso{
\code{\link[=read_env]{read_env()}}, \code{\link[=parse_id]{parse_id()}}, \code{\link[=add_info]{add_info()}}, \code{\link[=plot_env]{plot_env()}}
}
